---
title: "extraChIPs: Differential Signal Analysis"
author:
- name: Stevie Pederson
  affiliation: 
  - Black Ochre Data Laboratories, Telethon Kids Institute, Adelaide, Australia
  - Dame Roma Mitchell Cancer Researc Laboratories, University of Adelaide
  - John Curtin School of Medical Research, Australian National University
  email: stephen.pederson.au@gmail.com
package: extraChIPs
bibliography: '`r system.file("references.bib", package = "extraChIPs")`'
output:
  github_document
vignette: >
  %\VignetteIndexEntry{Differential Signal Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(
  message = FALSE, warning = FALSE, fig.height = 8, fig.width = 10
)
```


# Introduction

The [GRAVI](https://github.com/smped/GRAVI) workflow, for which this package 
is designed, uses sliding windows for differential signal analysis in a manner 
similar to the package `csaw`, but also incorporating `macs2` peaks.
The workflow itself extends to integrating multiple ChIP targets and external 
data sources, and as such, this package introduces a handful of functions to 
simplify and enable these analyses.
Whilst many existing approaches refer to this type of analysis as Differential
Binding analysis, we prefer the term *Differential Signal Analysis* as this more
accurately captures the range of ChIP targets which are likely to be 
investigated.

The majority of examples below use heavily reduced datasets to provide
general guidance on using the functions.
Some results may appear trivial as a result, but will hopefully prove far more
useful in a true experimental context.
All data, along with this vignette are available 
[here](https://github.com/smped/extraChIPs_vignette).
Please place all contents of the data directory in a directory named data in 
your own working directory.

# Setup 

## Installation

In order to use the package `extraChIPs` and follow this vignette, we recommend 
using the package `BiocManager` hosted on CRAN.
Once this is installed, the additional packages required for this vignette 
(`tidyverse`, `Rsamtools`, `csaw`, `BiocParallel` and `rtracklayer`) can also 
be installed.

```{r install, eval = FALSE}
if (!"BiocManager" %in% rownames(installed.packages()))
  install.packages("BiocManager")
pkg <- c(
  "tidyverse", "Rsamtools", "csaw", "BiocParallel", "rtracklayer", "edgeR", 
  "patchwork", "extraChIPs", "plyranges", "scales", "ggside"
)
BiocManager::install(pkg, update = FALSE)
```

Once these packages are installed, we can load them easily

```{r load-packages}
library(tidyverse)
library(Rsamtools)
library(csaw)
library(BiocParallel)
library(rtracklayer)
library(edgeR)
library(patchwork)
library(extraChIPs)
library(plyranges)
library(scales)
library(ggside)
```


## Data

All data for this vignette is expected to be in a sub-directory of the working 
directory named "data", and all paths will be predicated on this.
Please ensure you have all data in this location, obtained from 
[here](https://github.com/smped/extraChIPs_vignette).

The data itself is ChIP-Seq data targeting the histone mark H3K27ac, and is 
taken from the cell-line MDA-MB-453 under Vehicle and DHT-stimulated conditions.
Using CRCh37 as the reference genome, a subset of regions found on chromosome 10
are included in this dataset for simplicity.

`Seqinfo` objects are the foundation of working with GRanges, so let's define a
suitable object for consistency throughout th analysis.

```{r set-seqinfo}
hg19 <- GenomeInfoDb::getChromInfoFromUCSC("hg19")
grch37 <- hg19 %>% 
  dplyr::filter(chrom %in% paste0("chr", c(1:22, "X", "Y"))) %>% 
  mutate(genome = "GRCh37") %>% 
  dplyr::select(
    seqnames = chrom, seqlengths = size, isCircular = circular, genome
  ) %>% 
  as("Seqinfo")
```


# Working With Peaks

The provided dataset includes six files produced by `macs2 callpeak` 
[@Zhang2008-ms] in the `narrowPeak` format, and these are able to be easily 
parsed using `extraChIPs`.

```{r load-peaks}
peakFiles <- list.files("data", pattern = "narrowPeak", full.names = TRUE)
peaks <- importPeaks(peakFiles, seqinfo = grch37)
```

This will import the peaks from all files as a single `GRangesList` object, 
adding the file-name to each element by default.
We can easily modify these names if we so wish.

```{r change-names}
names(peaks) <- str_remove_all(names(peaks), "_peaks.narrowPeak")
```

Once loaded, we can easily check how similar our replicates are.

```{r plot-overlaps, fig.height=6, fig.cap = "*UpSet plot showing overlapping peaks across all replicates*"}
plotOverlaps(peaks, min_size = 10, .sort_sets = FALSE)
```

Optionally, specifying a column and a suitable function will produce an 
additional panel summarising that value.
In the following, we'll show the maximum score obtained, highlighting that for 
peaks identified in only one or two replicates, the overall signal intensity is
generally lower.

```{r plot-overlaps-score, fig.cap = "*UpSet plot showing overlapping peaks across all replicates, with the maximum score across all replicates shown in the upper panel.*"}
plotOverlaps(peaks, min_size = 10, .sort_sets = FALSE, var = "score", f = "max")
```

A common task at this point may be to define consensus peaks within each 
treatment group, by retaining only the peaks found in 2 of the 3 replicates.
The default approach is to take the union of all ranges, with the returned 
object containing logical values for each sample, as well as the number of 
samples where an overlapping peak was found.

If we wish to retain any of the original columns, such as the `macs2 callpeak` 
score, we can simply pass the column names to `makeConsensus()`

```{r consensus-with-score}
consensus_veh <- peaks %>% 
  .[str_detect(names(.), "Veh")] %>% 
  makeConsensus(p = 2/3, var = "score")
consensus_dht <- peaks %>% 
  .[str_detect(names(.), "DHT")] %>% 
  makeConsensus(p = 2 / 3, var = "score")
```

Alternatively, we could find the centre of the peaks as part of this process, 
by averaging across the estimated peak centres for each sample.
Whilst this is very common for *transcription factor* peaks, this may be less 
informative for other types of ChIP targets, such as the histone marks we have.

```{r consensus-with-centre}
consensus_veh <- peaks %>% 
  .[str_detect(names(.), "Veh")] %>% 
  endoapply(mutate, centre = start + peak) %>% 
  makeConsensus(p = 2/3, var = "centre") %>% 
  mutate(centre = vapply(centre, mean, numeric(1)))
consensus_dht <- peaks %>% 
  .[str_detect(names(.), "DHT")] %>% 
  endoapply(mutate, centre = start + peak) %>% 
  makeConsensus(p = 2/3, var = "centre") %>% 
  mutate(centre = vapply(centre, mean, numeric(1)))
```

We can also inspect these using `plotOverlaps()` provided we use a `GRangesList`
for the input.

```{r venn-consensus-overlap, fig.cap = "*Overlap between consensus peaks identified in a treatment-specific manner*"}
GRangesList(
  Veh = granges(consensus_veh), DHT = granges(consensus_dht)
) %>% 
  plotOverlaps(set_col = c("grey70", "red"))
```

We could go one step further and define the set of peaks found in either 
treatment.
Given we're being inclusive here, we can leave p = 0 so any peak found in 
either treatment is included.

```{r all_consensus}
all_consensus <- GRangesList(
  Veh = select(consensus_veh, centre), DHT = select(consensus_dht, centre)
) %>% 
  makeConsensus(var = "centre") %>% 
  mutate(centre = vapply(centre, mean, numeric(1)))
```

# Differential Signal Analysis

## Sliding Windows

The standard approach of tools such as DiffBind [@DiffBind2012] is to take a set
of peaks, re-centre them, then set all regions to be the same width.
From there, data is passed to `edgeR` [@edgeR2016] or `DESeq2` [@DESeq22014]
for analysis.
Whilst this approach can be replicated using the defined peaks above, the 
suggested approach for `extraChIPs` is to us sliding windows, as per `csaw`.
The resultant *variable width regions* can be particularly advantageous for ChIP 
targets such as H3K27ac where regions marked by histone-acetylation can vary 
greatly in size.

The starting point for differential signal analyses using `extraChIPs` is to 
define a set of sliding windows across the genome, then count reads from a set 
of bam files, defined as a `BamFileList.`
Commonly one or more IP input/control samples is also produced during a ChIP-Seq
experiment, and these should be included at this stage of the analysis.
The example files provided here contain a small subset of reads from chromosome 
10 across two experimental conditions and one input sample, and we will define 
them all as a `BamFileList`.

```{r bfl}
bfl <- list.files("data", pattern = "bam$", full.names = TRUE) %>% 
  BamFileList()
names(bfl) <- str_remove_all(names(bfl), ".bam")
```

**NB:** It should also be noted that counting all reads across a `BamFileList` 
using sliding windows, **will require a significant amount of RAM** and will be 
beyond the capacity of most laptops as of the time of writing.
When working with complete datasets, this step is best performed on an HPC or 
a similar interactive server.

The approach taken below is to first define a set of sliding windows across the 
genome, using the capabilities of `csaw`. 
After counting reads across all windows, a set of pre-defined regions is then 
used guide the function `dualFilter()` which will discard low-signal windows, 
retaining only those a) above a minimum signal level and b) with signal notably 
above that of any input samples.
These regions can be obtained from any external resource, or can even be taken 
from `macs2`-defined peaks from the same samples.

First we can define our windows and count the alignments using the existing 
capabilities and functions provided in the `csaw` package [@csaw2016].
In the following, we'll use a sliding window of 120bp and a step size of 40bp,
meaning each nucleotide is covered by 3 windows.
In addition, we'll exclude blacklisted and greylisted regions as provided in the
dataset.
These can be obtained easily by using the `GreyListChIP` package, which is 
beyond the scope of this vignette.

```{r wincounts}
greylist <- import.bed("data/chr10_greylist_subset.bed", seqinfo = grch37)
blacklist <- import.bed("data/chr10_blacklist_subset.bed", seqinfo = grch37)
rp <- readParam(
  pe = "none",
  dedup = TRUE,
  restrict = "chr10",
  discard = c(greylist, blacklist)
)
wincounts <- windowCounts(
  bam.files = bfl,
  spacing = 40,
  width = 120,
  ext = 200,
  filter = length(bfl),
  param = rp
)
```

This produces a `RangesSummarizedExperiment` with windows included which passed 
the minimum threshold of `r length(bfl)` total reads.
We can check which windows passed this threshold using `rowRanges()`

```{r show-ranges}
rowRanges(wincounts)
```

We can also add some key information to the `colData` element of this object, 
which will also be propagated to all downstream objects.

```{r update-coldata}
wincounts$sample <- names(bfl)
wincounts$treat <- str_extract(names(bfl), "(Veh|DHT)") %>% 
  fct(levels = c("Veh", "DHT"))
colData(wincounts)
```

A density plot can be simply drawn of these counts, with the vast majority of 
windows receiving very low counts, due to the nature of transcription factor 
binding, where long stretches are unbound.
The windows with higher counts tend to be associated with the samples targeting
a transcription factor (TF), as seen in the two treatment group samples.

```{r plot-densities, fig.cap = "*Read Densities for all returned windows across all samples*"}
plotAssayDensities(wincounts, colour = "treat", trans = "log1p") +
  theme_bw()
```


## Filtering of Sliding Windows

After counting all reads in the sliding genomic windows, the next step is to 
discard windows for which counts are unlikely to represent true signal from our 
ChIP target.
The strategy employed in `extraChIPs` uses a set of consensus peaks to 
automatically set thresholds based on 1) counts strongly above the counts from 
the input sample, and 2) the windows with the overall highest signal.
Thresholds are determined such that a proportion (e.g. `q = 0.5`) of the 
windows which overlap one of the supplied consensus peaks will be returned.
Higher values for `q` will return more windows, however many of these will 
tend to only marginally overlap a peak in one of the tail regions, and these 
will most likely be covered by neighbouring windows.
Experience has shown that values such as `q = 0.5` tend to return a considerable
proportion of windows containing true signal from the ChIP target.

The we can pass these to the function `dualFilter()` which utilises the strategy
described above.
On large datasets, this can be quite time-consuming, as can the initial counting
step.
Multiple alternative filtering strategies are also provided by the package 
`csaw` and these can be accessed using `?csaw::filterWindows`

```{r filtcounts}
filtcounts <- dualFilter(
  x = wincounts[, !is.na(wincounts$treat)],
  bg = wincounts[, is.na(wincounts$treat)], 
  ref = all_consensus,
  q = 0.6
)
```

Thus we have reduced our initial set of `r comma(nrow(wincounts))` sliding 
windows to the `r comma(nrow(filtcounts))` windows most likely to contain true
signal from our ChIP target.
The returned object will by default contain `counts` and `logCPM` assays, with
the complete library sizes used for the calculation of `logCPM` values.
Similarly, *the input sample is no longer included* in the data object, 
although additional columns can easily be added to the returned object using 
any number of strategies.

```{r show-dimensions}
dim(wincounts)
dim(filtcounts)
assays(filtcounts)
```

We can once again check our signal distributions, this time on the logCPM 
values.

```{r plotcpm, fig.cap = "*Densities for logCPM values across all samples after discarding windows less likely to contain H3K27ac signal*"}
plotAssayDensities(filtcounts, assay = "logCPM", colour = "treat") +
  scale_colour_brewer(palette = "Set1") +
  theme_bw()
```

The `rowData` element of the returned object will contain a logical column 
indicating where each specific retained window overlapped one of the supplied 
consensus peaks.

```{r filt-ranges}
rowRanges(filtcounts)
mean(rowRanges(filtcounts)$overlaps_ref)
```

## Initial Visualisation

Inspecting your data is a common first step, and a common QC step is Relative 
Log-Expression (RLE) [@Gandolfo2018-oc].
In the following, we first inspect the RLE across the entire dataset, followed 
by RLE grouping *within treatments*.
This can be particularly useful when distributions vary significantly between 
treatment groups, such as may occur with a cytoplasmic to nuclear shift by a 
given ChIP target.
Here, however, there is minimal difference between the two approaches as H3K27ac 
signal tends to be broadly consistent between these treatment groups.

```{r plot-assay-rle, fig.height=7, fig.cap = "*RLE plots across all samples (A) and with values calculated within treatment groups (B).*"}
a <- plotAssayRle(filtcounts, assay = "logCPM", fill = "treat") +
  geom_hline(yintercept = 0, linetype = 2, colour = "grey") +
  scale_fill_brewer(palette = "Set1") +
  ggtitle("RLE: Across All Samples") +
  theme_bw()
b <- plotAssayRle(
  filtcounts, assay = "logCPM", fill = "treat", rle_group = "treat"
) +
  geom_hline(yintercept = 0, linetype = 2, colour = "grey") +
  scale_fill_brewer(palette = "Set1") +
  ggtitle("RLE: Within Treatment Groups") +
  theme_bw()
a + b + plot_layout(guides = "collect") + 
  plot_annotation(tag_levels = "A")
```

We can also check the samples using a PCA plot, again colouring the points by 
treatment group and adding labels, which will repel by default if the points are 
shown.

```{r plot-pca, fig.height=6, fig.width=8, fig.cap = "*PCA plot based on the logCPM assay*"}
plotAssayPCA(filtcounts, "logCPM", colour = "treat", label = "sample") +
  scale_colour_brewer(palette = "Set1") +
  theme_bw()
```

## Statistical Testing

Multiple methods are enabled in the package `extraChIPs` via the function 
`fitAssayDiff()`, with the possibility of incorporating any additional 
normalisation strategies from external packages.
The two basic strategies are 1) Quasi-Likelihood Fits [@Lund2012-xo] and 2) 
`limma-trend` [@Law2014-xq].
This first (method = "qlf") uses counts with any of the provided normalisation 
strategies from `edgeR::calcNormFactors()`, and setting the normalisation 
method to "none" is the equivalent of library-size normalisation, which 
replicates the default normalisation strategy from DiffBind [@DiffBind2012].
If choosing to normalise within treatment groups, a factor can be provided via 
the groups argument, essentially adding this as an option for all methods 
provided in `edgeR::calcNormFactors()`.
The second method (method = "lt") is specifically for logCPM values and these 
can be provided as output by `dualFilter()` or may be normalised using 
any number of additional methods.
In addition to the above methods, a range-based $H_0$ [@McCarthy2009-qf] can be 
specified by providing a value to the `fc` or `lfc` arguments.

Here, we'll fit our data using Quasi-Likelihood Fits, library-size 
normalisation and setting a change in signal beyond the range of $\pm$ 20% as 
being of interest.
By default, the returned object, will contain the results from model fitting in 
the `rowData()` element as these are result associated with each row element in
the `SummarizedExperiment` object.
If the object is a `RangedSummarizedExperiment` object, setting 
`asRanges = TRUE` will simply return the set of GRanges along with the testing 
results.

```{r fit}
X <- model.matrix(~treat, data = colData(filtcounts))
fit_gr <- fitAssayDiff(filtcounts, design = X, fc = 1.2, asRanges = TRUE)
```


## Merging Windows

After an analysis has been performed, common values contained in the output may
be estimated signal (`logCPM`), estimated change (`logFC`) with both raw and 
adjusted p-values.
Given the dependency of neighbouring windows, any adjusted p-values will not be
appropriate and a merging of overlapping and/or neighbouring windows should be 
performed.
Multiple `csaw` methods are wrapped using `mergeByCol()`, `mergeBySig()` with 
minor changes to the returned object, such as the inclusion of the 
representative range in the column `keyval_range`.

For this vignette, we'll merge using the asymptotically exact harmonic mean 
p-value, which can also be used for merging dependent p-values [@Wilson2019-ln].
When merging windows using the harmonic mean p-values, instead of values from a
representative window, weighted averages for the expression and logFC estimates 
are returned using the weights $w_i = \frac{1}{p_i}$.
A representative window, corresponding to the original window with the lowest 
p-value is returned.

```{r merge-by-hmp}
results_gr <- mergeByHMP(fit_gr, inc_cols = "overlaps_ref", merge_within = 120)
results_gr$status <- case_when(
  results_gr$hmp_fdr > 0.05 ~ "Unchanged",
  results_gr$logFC > 0 ~ "Increased",
  results_gr$logFC < 0 ~ "Decreased"
)
arrange(results_gr, hmp)[1:5]
```

In the above, we returned `r sum(results_gr$hmp_fdr < 0.05)` ranges which we 
might consider using the significance threshold $\alpha$ = 0.05.
A particularly beneficial feature of this approach is that the final ranges 
will be of highly variable width, with this select region of chromosome 10 
producing merged windows ranging from `r min(width(results_gr))` to 
`r max(width(results_gr))`bp, as may be expected for H3K27ac signal.

We can also quickly check out results using a heatmap across the retained 
windows which correspond to our results for differential signal, although this
will not provide any specific genomic context.

```{r plot-assay-heatmap, fig.cap = "*Heatmap showing retained sliding windows whih correspond to the most highly-ranked region for differential signal.*"}
filtcounts %>%
  subsetByOverlaps(subset(results_gr, hmp == min(hmp))) %>%
  plotAssayHeatmap(assay = "logCPM", ysideline = TRUE, yside_col = "treat") +
  scale_fill_viridis_c() +
  scale_colour_brewer(palette = "Set1") +
  scale_ysidex_continuous(expand = expansion(0.1), minor_breaks = NULL) +
  theme_bw()
```


## Mapping of Windows To Genes

Once the changes in signal for our given ChIP target have been determined, a 
common next step is to assess which genes are likely to be impacted.
Whilst no definitive, single methodology exists for this process, the function
`mapByFeature()` offers an intuitive approach, taking into account any 
previously defined regulatory features.
These regulatory features may be defined by simple proximity to TSS regions, by
histone marks, downloaded from external repositories or any other possibility.
Whilst these features can improve the precision of mapping, even without these
this function can still enable a useful assignment of target gene to binding 
event.

The process undertaken inside `mapByFeature()` is a sequential checking of each 
range's association with regulatory features and the most likely target as a 
result.
These steps are:

1. **Check for any HiC interactions**
+ All genes which directly overlap an interaction anchor are considered part 
of the regulatory network for that interaction, and as such, all genes 
associated with both anchors are assigned to a peak which overlaps a HiC 
Interaction
2. **Check for any overlaps with a promoter** 
+ All genes regulated by that promoter are assigned as regulatory targets.
By default, this is by direct promoter/gene overlap (`prom2gene = 0`)
3. **Check for any overlaps with an enhancer**
+ Peaks which overlap an enhancer are assigned to *all* genes within the 
distance specified by `enh2gene` (default = 100kb)
4. **Check for genes with no previous mappings**
+ Peaks *with no previous mappings* are assigned to all directly overlapping 
genes, or the nearest gene within a specified distance 
(default `gr2gene` = 100kb)

As a result, if no promoters, enhancers or long-range interactions are 
supplied, all genes will be mapped to peaks using step 4.

A set of annotated regions has been provided for our subset of chromosome 10, as
has the set of genes within this region.
These can be loaded as follows.

```{r load-annotations}
regions <- read_rds("data/chr10_region_subset.rds")
genes <- import.gff("data/chr10_gene_subset.gtf")
```


For our mapping steps, we'll simply use the `promoters` element as these are 
the regions directly overlapping a TSS for all transcripts within this region 
of the genome.

```{r map-to-genes}
results_gr <- mapByFeature(results_gr, genes = genes, prom = regions$promoters)
```

Now we have our regions showing changed signal along with the likely regulatory 
targets.
Our top-ranked region is as follows, and this appears to be associated with the 
gene *`r arrange(results_gr, hmp)$gene_name[[1]]`*.

```{r top-ranked}
arrange(results_gr, hmp)[1]
```

### Mapping of Windows to Regions

If we also have a set of annotated regions, we can easily map our regions to 
the region that it has the greatest proportion of overlap.
First, we'll arrange our regions to be a single `GRanges` object with the column
"region".
From these we cn simply add the column `bestRegion`

```{r map-to-regions}
regions_gr <- regions %>% 
  lapply(select, region) %>% 
  GRangesList() %>% 
  unlist() %>% 
  sort() %>% 
  setNames(NULL)
region_levels <- vapply(regions, function(x) x$region[1], character(1))
results_gr$bestRegion <- results_gr %>% 
  bestOverlap(regions_gr, var = "region") %>% 
  fct(levels = region_levels)
```


# Visualisation of Results

## Association with Annotated Features

The association of windows or peaks with defined features, such as histone 
marks or regulatory elements can be important for describing the binding
characteristics of any given transcription factor.
We have already defined the association of the merged windows with annotated 
regions, and we can easily visualise these using `plotPie()`.

```{r plot-basic-pie, eval=FALSE}
results_gr %>% 
  plotPie(fill = "bestRegion")
```

However, given the default plots can often be slightly unsatisfactory, 
`plotPie()` is heavily customisable, in particular taking advantage of the 
`glue` syntax to customise labels.

```{r plot-pie, fig.width=8, fig.height=6, fig.cap = "*Pie chart showing the best overlapping region for each merged windows. The best overlap is determined simply by the region with the lergest amount of overlap.*"}
results_gr %>% 
  plotPie(
    fill = "bestRegion", min_p = 0.05, total_size = 5,
    cat_alpha = 0.5,
    cat_glue = "{str_wrap(bestRegion, 10)}\n{n}\n{percent(p, 0.1)}"
  )
```

We can also scale by additional columns.
Here, we'll find the proportion of each window which overlaps each type of 
region, providing a complete summary of the proportion of our ranges which 
overlaps each feature.

```{r plot-pie-width, fig.width=8, fig.height=6, fig.cap = "*Pie chart with regions scaled by width to show the proportions of the total regions which overlap each type of annotated region.*"}
regions %>% 
  lapply(function(x) propOverlap(results_gr, x)) %>% 
  as_tibble() %>% 
  mutate(range = as.character(results_gr)) %>% 
  pivot_longer(cols = names(regions), names_to = "region", values_to = "p") %>% 
  dplyr::filter(p > 0) %>% 
  mutate(
    region = fct(region_levels[region], levels = region_levels),
    w = p * width(GRanges(range)) / 1e3
  ) %>% 
  plotPie(
    scale_by = "w", fill = "region", min_p = 0.05,
    total_glue = "{round(N, 1)}kb", total_size = 5,
    cat_glue = "{str_wrap(region, 10)}\n{percent(p, 0.1)}",
    cat_alpha = 0.5, cat_size = 4
  )
```

These results can be extended further using `plotSplitDonut()` to show more 
complex results.

```{r plot-basic-donut, eval = FALSE}
results_gr %>% 
  plotSplitDonut(inner = "status", outer = "bestRegion")
```


Again, this plot is heavily customisable, and is able to utilise separate
palettes for the inner and outer rings if preferred.
Specific slices can also be *exploded* for emphasis.

```{r plot-split-donut, fig.cap = "*Summary of regions with changed signal and the annotated region with the largest overlap*"}
region_col <- hcl.colors(length(region_levels), "Viridis", rev = TRUE)
results_gr %>% 
  subset(status != "Unchanged") %>% 
  plotSplitDonut(
    inner = "status", outer = "bestRegion", min_p = 0.01,
    inner_palette = c("#3333E6", "#E6334D"),
    outer_palette = region_col,
    inner_glue = "H3K27ac\n{status}\n{n}", inner_label_alpha = 0.8,
    outer_glue = "{str_wrap(bestRegion, 10)}\n{n}", outer_label = "text",
    explode_outer = "Promoter", explode_r = 0.2
  ) 
```



## Profile Heatmaps

A very common approach to visualising the results of altered TF binding is to 
plot *profile heatmaps* centred around the window (or peak), and extending out 
a given number of of bases.
The data required for this is referred to in `extraChIPs` as profile data, and
given that extracting this from a set of `BigWigFile`s can be time consuming,
this step is performed prior to the actual plotting, so that ranges can be added
or excluded as desired.

First we need to define a `BigWigFileList` as these are conventionally very 
large files which shouldn't be retained in memory, but are just accessed to
import the key regions for a particular process.
Typically, these can be generated during peak calling but they can also be 
created directly from `bam` files if needed.
Once again, our reduced dataset makes this trivial, but the process may require 
significant computation resources if being performed on a complete dataset.
In the following, we'll create the BigWig files an immediately create our 
`BigWigFileList`.

```{r make-bwfl}
sbp <- ScanBamParam(which = GRanges("chr10:40000000-100000000"))
## Sum the coverage across all Vehicle samples then create a merged BigWig
cov_veh <- names(bfl) %>% 
  str_subset("Veh") %>% 
  lapply(function(x) coverage(bfl[[x]], param = sbp)$chr10) %>% 
  RleList() %>% 
  unlist()
cov_veh <- GRanges(RleList(chr10 = cov_veh))
export(cov_veh, "data/Veh_merged.bw")
## Repeat for DHT
cov_dht <- names(bfl) %>% 
  str_subset("DHT") %>% 
    lapply(function(x) coverage(bfl[[x]], param = sbp)$chr10) %>% 
  RleList() %>% 
  unlist()
cov_dht <- GRanges(RleList(chr10 = cov_dht))
export(cov_dht, "data/DHT_merged.bw")
bwfl <- BigWigFileList(
  list(Veh = "data/Veh_merged.bw", DHT = "data/DHT_merged.bw")
)
```

Now we have our `BigWigFileList` we can define the ranges to plot along with the
profile data.
In order to find the region within each range with the maximal signal, we'll 
compare back to the original results before windows were merged, then return 
the original window with the maximal signal (i.e. logCPM).
Note that we already had the windows in "keyval_range" which corresponded to 
the ranges with the most statistically significant change.
Realistically we can choose any strategy for centring ranges that we wish.

```{r get-max-ranges}
gr_increase <- subset(results_gr, status == "Increased")
max_peaks <- gr_increase %>%
  granges() %>%
  join_overlap_left(
    mutate(fit_gr, window = as.character(fit_gr))
  ) %>% 
    arrange(1/logCPM) %>% 
    distinctMC(.keep_all = TRUE) %>% 
    colToRanges("window") %>% 
    granges()
```

Now we've found the original windows with the strongest signal, we can define 
the profile data using the surrounding regions.
Our widest region with significant change in signal is 
`r max(width(subset(results_gr, status == "Increased")))`bp, so let's set our 
profiles to be created stretching 10kb either side of the peak centre.

```{r get-profile}
pd <- getProfileData(bwfl, max_peaks, upstream = 1e4, log = FALSE)
pd
```

This produces a `GRangesList` with a `GRanges` element for every file in the 
`BigWigFileList`, which has the profile data stored in the final column.
Each element of these columns is a `DataFrame` with the region broken into a 
defined number of bins, and an average coverage value calculated.
We can then simply plot this data by specifying this column in the function
`plotProfileHeatmap()`, which produces a `ggplot2` object able to be 
customised in the conventional manner.
Here, we'll add a colour scale and `theme_bw()`

```{r profile-heatmap, fig.cap = "*Profile Heatmap of the regions on chromosome 10 showing evidence for increased H3K27ac signal. Regions are centred at the point of maximal signal.*"}
plotProfileHeatmap(pd, "profile_data") +
  scale_fill_gradient(low = "white", high = "red") +
  labs(fill = "Counts") +
  theme_bw()
```

Note that H3K27ac often contains regions with significantly lower signal where 
the transcriptional machinery is instead occupying the DNA and as such, H3K27ac 
peaks are often centred using peaks from an additional transcription factor.
Here, we've also just plotted raw counts.
`macs2` is able to produce BigWigFiles containing logCPM values, or enrichment 
over input and these are often used in preference to raw counts.

## Inspection of Ranges

Another important step in the analysis of ChIP-Seq data is to look at the 
binding patterns using coverage, and inspect these in reference to genes and any 
other feature of interest.
The function `plotHFGC()` provides a simple, standardised layout using the
visualisation tools from `Gviz`.
If supplied, tracks will be drawn in the order 1) HiC; 2) Features; 3) Genes, 
and 4) Coverage.
All tracks are optional, and if none are provided a simply cytogenetic plot will
be produced.
Whilst a simple and intuitive function to use, it also provides a great deal of 
flexibility for advanced customisation.
All plots require a `GRanges` object to define the plotting region along with a 
set of cytogenetic bands.
These are provided in the package for GRCh37 and GRCh38.


Let's start by plotting the first promoter showing changed signal in 
`results_gr` using the minimal data possible.
This is a `GRanges` object and some cytogenetic bands.

```{r plot-empty-hfgc, fig.height=6, fig.cap = "*Basic output from plotHFGC without any of the optional tracks*"}
data("grch37.cytobands")
gr <- results_gr %>%
  subset(hmp_fdr < 0.05) %>% 
  subset(vapply(gene_name, function(x) "PRXL2A" %in% x, logical(1))) %>% 
  subset(logCPM == max(logCPM))
plotHFGC(gr, cytobands = grch37.cytobands)
```

### Including Coverage

In order to show our changed signal in context we can show the coverage using a
`BigWigFileList` as for the Profile Heatmap.
If providing a `BigWigFileList`, separate tracks will drawn for each element of 
the object.
In more complex scenarios where multiple targets are required a list of 
`BigWigFileList`s can be provided and each element will then be drawn as a track 
with overlapping coverage within each BigWigFileList.
Colours need to be provided in the identical structure to match the provided 
object.
Here, we've provided a single `BigWigFileList` so we can provide a simple list 
matching the names within the `BigWigFileList.`

```{r plot-hfgc-coverge, fig.height=6, fig.cap = "*Coverage for the region of interest, shown with a blue highlight. Note how the counts are lower in the highlighted region for the merged Veh coverage track.*"}
plotHFGC(
  gr, cytobands = grch37.cytobands, 
  coverage = bwfl, linecol = list("Veh" = "grey30", "DHT" = "darkred"),
  zoom = 30
)
```


### Displaying Genes

Next we might like to add gene models to provide the regulatory context.
These are supplied here in the layout required by the defaults of the 
`GeneRegionTrack()` function, with all exons and transcripts annotated.

```{r add-genes, fig.cap = "*Coverage for our region showing the relationship of signal to annotated genes*"}
gene_models <- read_rds("data/chr10_trans_subset.rds")
plotHFGC(
  gr, cytobands = grch37.cytobands, 
  coverage = bwfl, linecol = list("Veh" = "grey30", "DHT" = "darkred"),
  genes = gene_models, genecol = "wheat",
  zoom = 30
)
```

### Adding Features

Another useful track to add might be some key features such as promoters and 
other annotated regions.
Features must **always** be a `GRangesList`, with each element defining a 
different type of feature, as we already have in our `regions_gr` object.

```{r plot-hfgc, fig.cap = "*The same figure as previously, but with annotated regions added as features. Any type of feature can be added here.*"}
region_grl <- splitAsList(regions_gr, regions_gr$region)[region_levels]
names(region_col) <- region_levels
plotHFGC(
  gr, cytobands = grch37.cytobands, 
  features = region_grl, featcol = region_col, featstack = "dense",
  coverage = bwfl, linecol = list("Veh" = "grey30", "DHT" = "darkred"),
  genes = gene_models, gene_col = "wheat",
  zoom = 30
)
```


### Adding HiC Interactions

If long-range interactions are available, these can also be provided as a 
GenomicInteractions object, completing all available options for the HFGC 
components.

### Adding Annotations To Coverage

An indication of which regions are associated with increased or decreased 
ChIP signal can also be a useful annotation to add to plots such as the above.
Although we technically performed no statistical testing, let's consider a
window with logFC below -1 to be showing decreased signal.

Similar to the features track, where the names of `GRangesList` elements denote
the different feature types, able to then assigned a colour, coverage annotation
tracks follow these same rules.
For each coverage track being annotated, a `GRangesList` object can denote the
ranges which can be assigned different colours.

```{r cov-annot}
cov_annot <- splitAsList(results_gr, results_gr$status) %>% 
  endoapply(granges)
```

In the above, we have Unchanged and Decreased signal denoted as annotations.
In keeping with the approach of having a matching list element for every 
coverage track, we would need to pass this as a list which matched the 
coverage track

```{r plot-annot, fig.cap = "*The addition of an annotation track for the coverage tracks shows which regions were retained during the analysis, as well as those which were considered as showing changed or unchanged signal.*"}
plotHFGC(
  gr, 
  features = region_grl, featcol = region_col, featstack = "dense",
  genes = gene_models, genecol = "wheat",
  coverage = bwfl, linecol = list("Veh" = "grey30", "DHT" = "darkred"),
  annotation = cov_annot, 
  annotcol = c(Unchanged = "grey", Decreased = "#3333E6", Increased = "#E6334D"),
  cytobands = grch37.cytobands, zoom = 30
)
```

Plots are able to be tweaked considerably further via multiple parameters, 
however these basic approaches cover the core functionality of `plotHFCG()`
for enabling simple & reproducible plotting across regions for multiple sites
within a larger experiment.

# References

<div id="refs"></div>
<br>

# Session Info

```{r session-info}
sessionInfo()
```

